"use strict";
// disable rules that trigger because the AddOn does not have type definitions
/* eslint-disable @typescript-eslint/no-unsafe-return,
                  @typescript-eslint/no-unsafe-assignment,
                  @typescript-eslint/no-unsafe-call,
                  @typescript-eslint/no-unsafe-member-access
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionBinding = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const util_1 = __importDefault(require("util"));
const worker_threads_1 = require("worker_threads");
const error_1 = require("./error");
const alerttime_1 = require("./alerttime");
// load the connection class from the DLL
//@ts-expect-error Importing an AddOn without type declaration
const winccoaconnection_1 = require("../../../bin/winccoaconnection");
class ConnectionBinding {
    constructor() {
        this._loopActive = false;
        this._exitCode = 0;
        this._connection = new winccoaconnection_1.WinccoaManagerConnection(process.argv);
        this._connection.registerErrorFactoryMethod((code, message, catalog, details) => new error_1.WinccoaError(code, message, catalog, details));
        this._connection.registerAlertTimeFactoryMethod((date, count, dp) => new alerttime_1.WinccoaAlertTime(date, count, dp));
        this.paths = this._connection.getPaths();
        this.log = {
            info: (...message) => this._connection.log(0, util_1.default.format(...message)),
            warning: (...message) => this._connection.log(1, util_1.default.format(...message)),
            severe: (...message) => this._connection.log(2, util_1.default.format(...message)),
            fatal: (...message) => this._connection.log(3, util_1.default.format(...message)),
        };
        // redirect console output to WinCC OA log
        console.log = this.log.info;
        console.info = this.log.info;
        console.warn = this.log.warning;
        console.error = this.log.severe;
        // log uncaught exceptions and exit
        process.on('uncaughtException', (error) => this.log.fatal(error.stack));
        process.on('unhandledRejection', (error) => this.log.fatal(error.stack));
        // exit with error code 0 on SIGTERM and ^C => ProjectConsole shows no crash
        const sigHandler = () => {
            process.exit(this._exitCode);
        };
        process.on('SIGINT', sigHandler);
        process.on('SIGTERM', sigHandler);
        // exit the manager once the event loop is closing
        process.on('exit', (code) => this._connection.managerExit(code));
        // verify that this is not executed in a worker thread
        if (!worker_threads_1.isMainThread) {
            throw new Error('Must be executed in main thread!');
        }
    }
    start() {
        if (this._loopActive)
            return -1;
        // uncomment the next line to change the dispatch wait time
        // this.log.info('Dispatch wait time: ' + this._connection.setDispatchWaitMs(10) + ' ms');
        this._connection.managerStart();
        this._loopActive = true;
        this._singleDispatch();
    }
    exit(exitCode = 0) {
        if (!this._loopActive)
            return;
        this._exitCode = exitCode;
        this._loopActive = false;
    }
    findFile(fileDirName, searched) {
        for (let i = 0; i < this.paths.length; i++) {
            const joinedPath = path_1.default.join(this.paths[i], fileDirName);
            if (fs_1.default.existsSync(joinedPath)) {
                return joinedPath;
            }
            if (searched) {
                searched.push(joinedPath);
            }
        }
        return '';
    }
    static getInstance() {
        if (!ConnectionBinding._instance) {
            ConnectionBinding._instance = new ConnectionBinding();
        }
        return ConnectionBinding._instance;
    }
    _singleDispatch() {
        this._connection.managerDispatch();
        if (this._loopActive && !this._connection.exitSignalReceived())
            setImmediate(() => this._singleDispatch());
        else
            process.exit(this._exitCode);
    }
}
exports.ConnectionBinding = ConnectionBinding;
